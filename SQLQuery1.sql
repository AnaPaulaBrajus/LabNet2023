--Ejercicio 1
SELECT ID, LAST_NAME, HIRE_DATE, SALARY 
FROM TEST.EMPLOYEES
WHERE SALARY is not null

--Ejercicio 2
SELECT ID, LAST_NAME, HIRE_DATE, SALARY*12 as 'Salario anual'
FROM TEST.EMPLOYEES
WHERE SALARY is not null

--Ejercicio 4
SELECT ID, LAST_NAME + ' ' + FIRST_NAME as 'Apellido y nombre', HIRE_DATE, SALARY 
FROM TEST.EMPLOYEES
WHERE SALARY is not null

--Ejercicio 5 a
SELECT DISTINCT DEPARTMENT_ID 
FROM TEST.EMPLOYEES

--Ejercicio 5 b
SELECT DEPARTMENT_ID 
FROM TEST.EMPLOYEES 
GROUP BY DEPARTMENT_ID

--Ejercicio 6
SELECT *
FROM TEST.EMPLOYEES
WHERE SALARY < 2000 

--Ejercicio 7
SELECT * 
FROM TEST.EMPLOYEES
WHERE SALARY BETWEEN 1800 and 3000

--Ejercicio 8
SELECT * 
FROM TEST.EMPLOYEES
WHERE DEPARTMENT_ID in(10,30,31)

--Ejercicio 9
SELECT *
FROM TEST.EMPLOYEES
WHERE LAST_NAME like 'F%'

--Ejercicio 10 a
SELECT *
FROM TEST.EMPLOYEES
WHERE JOB_ID is null

--Ejercicio 10 b
SELECT *
FROM TEST.EMPLOYEES
WHERE JOB_ID is not null

--Ejercicio 11
SELECT *
FROM TEST.EMPLOYEES
WHERE (JOB_ID='AD_CTB' or JOB_ID='FQ_GRT') and SALARY>1900

--Ejercicio 13
SELECT *
FROM TEST.EMPLOYEES
ORDER BY  HIRE_DATE ASC

--Ejercicio 14
SELECT *
FROM TEST.EMPLOYEES
ORDER BY  HIRE_DATE DESC, LAST_NAME ASC

--Ejercicio 15
SELECT LAST_NAME, 12*SALARY as salario_anual
FROM TEST.EMPLOYEES
ORDER BY salario_anual

--Ejercicio 17
SELECT e.*, DEPARTMENT_NAME
FROM TEST.EMPLOYEES e
JOIN TEST.DEPARTMENTS d
ON e.DEPARTMENT_ID = d.ID

--Ejercicio 18
SELECT e.*, DEPARTMENT_NAME
FROM TEST.EMPLOYEES e
LEFT JOIN TEST.DEPARTMENTS d
ON e.DEPARTMENT_ID = d.ID

--Ejercicio 19
SELECT d., e.
FROM TEST.DEPARTMENTS d
LEFT JOIN TEST.EMPLOYEES e
ON d.ID=e.DEPARTMENT_ID

--Ejercicio 20 DUDAS
SELECT m.MANAGER_ID, m.FIRST_NAME, m.LAST_NAME, s.ID, s.FIRST_NAME, s.LAST_NAME
FROM TEST.EMPLOYEES m
LEFT JOIN TEST.EMPLOYEES s 
ON m.MANAGER_ID = s.ID
ORDER BY m.MANAGER_ID, s.ID

--Ejercicio 21
SELECT MAX(SALARY) Maximo, MIN(SALARY) Minimo, AVG(SALARY) Promedio, SUM(SALARY) Suma
FROM TEST.EMPLOYEES

--Ejercicio 22 No tiene sentido calcular el AVG ni el SUM
SELECT MAX(HIRE_DATE) Maximo, MIN(HIRE_DATE) Minimo, SUM(DATEDIFF(DAY, HIRE_DATE, GETDATE())) Suma
FROM TEST.EMPLOYEES

--Ejercicio 23
SELECT DEPARTMENT_ID, COUNT(*) as 'Cant de empleados'
FROM TEST.EMPLOYEES
GROUP BY DEPARTMENT_ID

--Ejercicio 24
SELECT DEPARTMENT_ID, JOB_ID, COUNT(*) as 'Cant de empleados'
FROM TEST.EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID

--Ejercicio 25
SELECT DEPARTMENT_ID, AVG(SALARY) as 'Salario promedio'
FROM TEST.EMPLOYEES 
GROUP BY DEPARTMENT_ID

--Ejercicio 26-27
INSERT INTO TEST.DEPARTMENTS (ID, DEPARTMENT_NAME, LOCATION_ID, DEPARTMENT_DESCRIPTION) 
VALUES (60, 'Sistemas', 2, 'Soporte');

INSERT INTO TEST.EMPLOYEES(ID, FIRST_NAME,LAST_NAME,SALARY,DEPARTMENT_ID,JOB_ID,HIRE_DATE,MANAGER_ID)
VALUES(19,'Ana Paula', 'Brajús', 2000.6, 60,'FQ_OPR', '2009-03-24', 4 )

INSERT INTO TEST.JOBS (ID, JOB_NAME) 
VALUES ('FQ_LID', 'Lider');

INSERT INTO TEST.LOCATIONS (ID, CITY) 
VALUES (4, 'Gualeguaychú');

--Ejercicio 28 Los campos obligatorios son los que tiene el not null
-- De TEST.DEPARTMENTS-->ID, DEPARTMENT_NAME, LOCATION_ID
-- De TEST.EMPLOYEES-->ID, FIRST_NAME, LAST_NAME
-- De TEST.JOBS-->ID, JOB_NAME
-- De TEST.LOCATIONS-->ID, CITY

--Ejercicio 29
INSERT INTO TEST.EMPLOYEES(ID, FIRST_NAME,LAST_NAME,SALARY,DEPARTMENT_ID,JOB_ID,HIRE_DATE,MANAGER_ID)
SELECT 20, 'Juan', LAST_NAME,SALARY+200,DEPARTMENT_ID,JOB_ID,HIRE_DATE, NULL
FROM TEST.EMPLOYEES
WHERE FIRST_NAME = 'Gustavo' and LAST_NAME = 'Boulette'

--Ejercicio 30
UPDATE TEST.EMPLOYEES
SET SALARY=1100.00
WHERE ID = 10; 

--Ejercicio 1
UPDATE TEST.EMPLOYEES
SET SALARY=SALARY*1.1
WHERE DEPARTMENT_ID = 40; 

--Ejercicio 2 Tuve que borrarlo desde empleados primero y luego de departamentos
SELECT *
FROM TEST.DEPARTMENTS
WHERE ID > 50

SELECT *
FROM TEST.EMPLOYEES
WHERE DEPARTMENT_ID > 50

DELETE FROM TEST.EMPLOYEES
WHERE DEPARTMENT_ID >50

DELETE FROM TEST.DEPARTMENTS
WHERE ID>50

--Ejercicio 3 me da el error "The DELETE statement conflicted with the SAME TABLE REFERENCE constraint "EMP_EMP". The conflict occurred in database "PracticaSQL", table "TEST.EMPLOYEES", column 'MANAGER_ID'.
SELECT *
FROM TEST.DEPARTMENTS
WHERE ID = 40

SELECT *
FROM TEST.EMPLOYEES
WHERE DEPARTMENT_ID = 40

DELETE FROM TEST.EMPLOYEES
WHERE DEPARTMENT_ID = 40

DELETE FROM TEST.DEPARTMENTS
WHERE ID=40

--Ejercicio 4
CREATE FUNCTION fn_AntiguedadEmpleado(@Empleado_id INT)
RETURNS INT
AS
BEGIN
    DECLARE @Antiguedad INT;
    DECLARE @Fecha_contratacion DATE;

    SELECT @Fecha_contratacion = HIRE_DATE
    FROM TEST.EMPLOYEES
    WHERE ID = @Empleado_id;

    SET @Antiguedad = DATEDIFF(YEAR, @Fecha_contratacion, GETDATE());

    RETURN @Antiguedad;
END;

--Ejercicio 31
CREATE PROCEDURE sp_GetNombreAntiguedad
AS
BEGIN
    SELECT
        CONCAT(FIRST_NAME, ' ', LAST_NAME) AS NombreCompleto,
        dbo.fn_AntiguedadEmpleado(ID) AS AntiguedadEnAnos
    FROM TEST.EMPLOYEES
    ORDER BY AntiguedadEnAnos DESC;
END;

--Ejercicio 
CREATE TABLE AUDITORIA (ID INT PRIMARY KEY AUTO_INCREMENT, OPERACION VARCHAR(10), FECHA DATETIME)

CREATE TRIGGER Trig_Auditoria
AFTER INSERT ON TEST.EMPLOYEES
FOR EACH ROW
BEGIN
    INSERT INTO AUDITORIA (OPERACION, FECHA)
    VALUES ('INSERT', NOW());
END;
//
DELIMITER ;